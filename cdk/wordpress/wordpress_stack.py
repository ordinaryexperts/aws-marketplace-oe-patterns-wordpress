import json
import os
import subprocess
import yaml
from aws_cdk import (
    aws_autoscaling,
    aws_cloudformation,
    aws_cloudwatch,
    aws_codebuild,
    aws_codedeploy,
    aws_codepipeline,
    aws_codepipeline_actions,
    aws_ec2,
    aws_efs,
    aws_elasticloadbalancingv2,
    aws_iam,
    aws_lambda,
    aws_logs,
    aws_rds,
    aws_route53,
    aws_s3,
    aws_secretsmanager,
    aws_sns,
    aws_ssm,
    core
)

from oe_patterns_cdk_common import (
    Util,
    Vpc
)

DEFAULT_WORDPRESS_SOURCE_URL="https://ordinary-experts-aws-marketplace-wordpress-pattern-artifacts.s3.amazonaws.com/aws-marketplace-oe-patterns-wordpress-default/refs/heads/develop.zip"
TWO_YEARS_IN_DAYS=731
if 'TEMPLATE_VERSION' in os.environ:
    template_version = os.environ['TEMPLATE_VERSION']
else:
    try:
        template_version = subprocess.check_output(["git", "describe"]).strip().decode('ascii')
    except:
        template_version = "CICD"

# When making a new development AMI:
# 1) $ ave oe-patterns-dev make ami-ec2-build
# 2) $ ave oe-patterns-dev make AMI_ID=ami-fromstep1 ami-ec2-copy
# 3) Copy the code that copy-image generates below

# AMI list generated by:
# make TEMPLATE_VERSION=1.1.0 ami-ec2-build
# on Wed Feb  3 19:33:55 UTC 2021.
AMI_ID="ami-0be384c69a5e5a4da"
AMI_NAME="ordinary-experts-patterns-wordpress-1.1.0-20210203-0721"
generated_ami_ids = {
    "ap-northeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-northeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ap-south-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-1": "ami-XXXXXXXXXXXXXXXXX",
    "ap-southeast-2": "ami-XXXXXXXXXXXXXXXXX",
    "ca-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-central-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-north-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "eu-west-3": "ami-XXXXXXXXXXXXXXXXX",
    "sa-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-1": "ami-XXXXXXXXXXXXXXXXX",
    "us-west-2": "ami-XXXXXXXXXXXXXXXXX",
    "us-east-1": "ami-0be384c69a5e5a4da"
}
# End generated code block.

# Sanity check: if this fails then make ami-ec2-copy needs to be run...
assert AMI_ID == generated_ami_ids["us-east-1"]

class WordPressStack(core.Stack):

    def __init__(self, scope: core.Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        #
        # INITIALIZATION
        #

        current_directory = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
        allowed_values = yaml.load(
            open(os.path.join(current_directory, "allowed_values.yaml")),
            Loader=yaml.SafeLoader
        )
        ami_mapping={
            "AMI": {
                "OEWORDPRESS": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "OEWORDPRESS": generated_ami_ids[region] }
        aws_ami_region_map = core.CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        #
        # PARAMETERS
        #

        alb_ingress_cidr_param = core.CfnParameter(
            self,
            "AlbIngressCidr",
            allowed_pattern="^((\d{1,3})\.){3}\d{1,3}/\d{1,2}$",
            default="0.0.0.0/0",
            description="Optional: VPC IPv4 CIDR block to restrict public access to ALB (default is 0.0.0.0/0 which is open to internet)."
        )
        app_instance_type_param = core.CfnParameter(
            self,
            "AppLaunchConfigInstanceType",
            allowed_values=allowed_values["allowed_instance_types"],
            default="m5.large",
            description="Required: The EC2 instance type for the application Auto Scaling Group."
        )
        asg_key_name_param = core.CfnParameter(
            self,
            "AppAsgKeyName",
            default="",
            description="Optional: EC2 key pair for SSH to instances. Note: AWS Session Manager is supported and is the recommended way to connect to instances.",
            type="String"
        )
        asg_desired_capacity_param = core.CfnParameter(
            self,
            "AppAsgDesiredCapacity",
            default=1,
            description="Required: The desired capacity of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        asg_max_size_param = core.CfnParameter(
            self,
            "AppAsgMaxSize",
            default=2,
            description="Required: The maximum size of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        asg_min_size_param = core.CfnParameter(
            self,
            "AppAsgMinSize",
            default=1,
            description="Required: The minimum size of the Auto Scaling Group.",
            min_value=0,
            type="Number"
        )
        certificate_arn_param = core.CfnParameter(
            self,
            "CertificateArn",
            description="Required: Specify the ARN of a ACM Certificate to configure HTTPS."
        )
        db_instance_class_param = core.CfnParameter(
            self,
            "DbInstanceClass",
            allowed_values=allowed_values["allowed_db_instance_types"],
            default="db.t3.medium",
            description="Required: The class profile for memory and compute capacity for the database instance."
        )
        db_snapshot_identifier_param = core.CfnParameter(
            self,
            "DbSnapshotIdentifier",
            default="",
            description="Optional: RDS snapshot ARN from which to restore. If specified, manually edit the secret values to specify the snapshot credentials for the application. WARNING: Changing this value will re-provision the database."
        )
        initialize_default_wordpress_param = core.CfnParameter(
            self,
            "InitializeDefaultWordPress",
            allowed_values=[ "true", "false" ],
            default="true",
            description="Optional: Trigger the first deployment with a copy of an initial default codebase from Ordinary Experts using WordPress Bedrock 5.6."
        )
        notification_email_param = core.CfnParameter(
            self,
            "NotificationEmail",
            default="",
            description="Optional: Specify an email address to get emails about deploys and other system events."
        )
        pipeline_artifact_bucket_name_param = core.CfnParameter(
            self,
            "PipelineArtifactBucketName",
            default="",
            description="Optional: Specify a bucket name for the CodePipeline pipeline to use. The bucket must be in this same AWS account. This can be handy when re-creating this template many times."
        )
        route_53_hosted_zone_name_param = core.CfnParameter(
            self,
            "Route53HostedZoneName",
            default="",
            description="Optional: Route 53 Hosted Zone name in which a DNS record will be created by this template. If supplied, must already exist and be the domain part of the WordPress Hostname parameter, without trailing dot. i.e. 'mycompany.com'"
        )
        secret_arn_param = core.CfnParameter(
            self,
            "SecretArn",
            default="",
            description="Optional: Secrets Manager secret ARN used to store database credentials and other configuration. If not specified, a secret will be created."
        )
        source_artifact_bucket_name_param = core.CfnParameter(
            self,
            "SourceArtifactBucketName",
            default="",
            description="Optional: Specify a S3 bucket name which will contain the build artifacts for the application. If not specified, a bucket will be created."
        )
        source_artifact_object_key_param = core.CfnParameter(
            self,
            "SourceArtifactObjectKey",
            default="wordpress.zip",
            description="Required: AWS S3 object key (path) for the build artifact for the application. Updates to this object will trigger a deployment."
        )
        word_press_hostname_param = core.CfnParameter(
            self,
            "WordPressHostname",
            allowed_pattern="^(?!.*\/).*$",
            constraint_description="WordPress Hostname should not have any forward slashes",
            default="",
            description="Optional: The hostname for the WordPress site, i.e. my-wordpress-site.mycompany.com - leave off the https:// and trailing slash."
        )

        #
        # CONDITIONS
        #
        asg_key_name_exists_condition = core.CfnCondition(
            self,
            "AsgKeyNameExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(asg_key_name_param.value, ""))
        )
        db_snapshot_identifier_exists_condition = core.CfnCondition(
            self,
            "DbSnapshotIdentifierExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(db_snapshot_identifier_param.value, ""))
        )
        initialize_default_wordpress_condition = core.CfnCondition(
            self,
            "InitializeDefaultWordPressCondition",
            expression=core.Fn.condition_equals(initialize_default_wordpress_param.value, "true")
        )
        notification_email_exists_condition = core.CfnCondition(
            self,
            "NotificationEmailExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(notification_email_param.value, ""))
        )
        pipeline_artifact_bucket_name_not_exists_condition = core.CfnCondition(
            self,
            "PipelineArtifactBucketNameNotExists",
            expression=core.Fn.condition_equals(pipeline_artifact_bucket_name_param.value, "")
        )
        pipeline_artifact_bucket_name_exists_condition = core.CfnCondition(
            self,
            "PipelineArtifactBucketNameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(pipeline_artifact_bucket_name_param.value, ""))
        )
        secret_arn_exists_condition = core.CfnCondition(
            self,
            "SecretArnExistsCondition",
            expression=core.Fn.condition_not(core.Fn.condition_equals(secret_arn_param.value, ""))
        )
        secret_arn_not_exists_condition = core.CfnCondition(
            self,
            "SecretArnNotExistsCondition",
            expression=core.Fn.condition_equals(secret_arn_param.value, "")
        )
        source_artifact_bucket_name_exists_condition = core.CfnCondition(
            self,
            "SourceArtifactBucketNameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(source_artifact_bucket_name_param.value, ""))
        )
        source_artifact_bucket_name_not_exists_condition = core.CfnCondition(
            self,
            "SourceArtifactBucketNameNotExists",
            expression=core.Fn.condition_equals(source_artifact_bucket_name_param.value, "")
        )
        route_53_hosted_zone_name_exists_condition = core.CfnCondition(
            self,
            "Route53HostedZoneNameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(route_53_hosted_zone_name_param.value, ""))
        )
        word_press_hostname_exists_condition = core.CfnCondition(
            self,
            "WordPressHostnameExists",
            expression=core.Fn.condition_not(core.Fn.condition_equals(word_press_hostname_param.value, ""))
        )

        #
        # RULES
        #

        db_snapshot_secret_rule = core.CfnRule(
            self,
            "DbSnapshotIdentifierAndSecretRequiredRule",
            assertions=[
                core.CfnRuleAssertion(
                    assert_=core.Fn.condition_not(core.Fn.condition_equals(secret_arn_param.value_as_string, "")),
                    assert_description="When restoring the database from a snapshot, a secret ARN must also be supplied, prepopulated with username and password key-value pairs which correspond to the snapshot image"
                )
            ],
            rule_condition=core.Fn.condition_not(
                core.Fn.condition_equals(db_snapshot_identifier_param.value_as_string, "")
            )
        )

        #
        # RESOURCES
        #

        pipeline_artifact_bucket = aws_s3.CfnBucket(
            self,
            "PipelineArtifactBucket",
            access_control="Private",
            bucket_encryption=aws_s3.CfnBucket.BucketEncryptionProperty(
                server_side_encryption_configuration=[
                    aws_s3.CfnBucket.ServerSideEncryptionRuleProperty(
                        server_side_encryption_by_default=aws_s3.CfnBucket.ServerSideEncryptionByDefaultProperty(
                            sse_algorithm="AES256"
                        )
                    )
                ]
            ),
            public_access_block_configuration=aws_s3.BlockPublicAccess.BLOCK_ALL
        )
        pipeline_artifact_bucket.cfn_options.condition=pipeline_artifact_bucket_name_not_exists_condition
        pipeline_artifact_bucket.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        pipeline_artifact_bucket.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        pipeline_artifact_bucket_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource=core.Token.as_string(
                    core.Fn.condition_if(
                        pipeline_artifact_bucket_name_exists_condition.logical_id,
                        pipeline_artifact_bucket_name_param.value_as_string,
                        pipeline_artifact_bucket.ref
                    )
                ),
                resource_name="*",
                service="s3"
            ),
            stack=self
        )
        source_artifact_bucket = aws_s3.CfnBucket(
            self,
            "SourceArtifactBucket",
            access_control="Private",
            bucket_encryption=aws_s3.CfnBucket.BucketEncryptionProperty(
                server_side_encryption_configuration=[
                    aws_s3.CfnBucket.ServerSideEncryptionRuleProperty(
                        server_side_encryption_by_default=aws_s3.CfnBucket.ServerSideEncryptionByDefaultProperty(
                            sse_algorithm="AES256"
                        )
                    )
                ]
            ),
            public_access_block_configuration=aws_s3.BlockPublicAccess.BLOCK_ALL,
            versioning_configuration=aws_s3.CfnBucket.VersioningConfigurationProperty(
                status="Enabled"
            )
        )
        source_artifact_bucket.cfn_options.condition = source_artifact_bucket_name_not_exists_condition
        source_artifact_bucket.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        source_artifact_bucket.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        source_artifact_bucket_name = core.Token.as_string(
            core.Fn.condition_if(
                source_artifact_bucket_name_exists_condition.logical_id,
                source_artifact_bucket_name_param.value_as_string,
                source_artifact_bucket.ref
            )
        )
        source_artifact_bucket_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource=source_artifact_bucket_name,
                service="s3"
            ),
            stack=self
        )
        source_artifact_object_key_arn = core.Arn.format(
            components=core.ArnComponents(
                account="",
                region="",
                resource=source_artifact_bucket_name,
                resource_name=source_artifact_object_key_param.value_as_string,
                service="s3"
            ),
            stack=self
        )

        # vpc
        vpc = Vpc(
            self,
            "Vpc"
        )

        app_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AppSg",
            group_description="{}/App".format(core.Aws.STACK_NAME),
            vpc_id=vpc.id()
        )
        core.Tags.of(app_sg).add("Name", "{}/AppSg".format(core.Aws.STACK_NAME))
        db_sg = aws_ec2.CfnSecurityGroup(
            self,
            "DbSg",
            group_description="{}/Db".format(core.Aws.STACK_NAME),
            vpc_id=vpc.id()
        )
        core.Tags.of(db_sg).add("Name", "{}/DbSg".format(core.Aws.STACK_NAME))
        db_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "DbSgIngress",
            description="Allow MySQL traffic to DbSg from AppSg",
            from_port=3306,
            group_id=db_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=3306
        )
        db_subnet_group = aws_rds.CfnDBSubnetGroup(
            self,
            "DbSubnetGroup",
            db_subnet_group_description=core.Aws.STACK_NAME,
            subnet_ids=vpc.private_subnet_ids()
        )
        db_cluster_parameter_group = aws_rds.CfnDBClusterParameterGroup(
            self,
            "DbClusterParameterGroup",
            description=core.Aws.STACK_NAME,
            family="aurora-mysql5.7",
            parameters={
                "character_set_client": "utf8",
                "character_set_connection": "utf8",
                "character_set_database": "utf8",
                "character_set_filesystem": "utf8",
                "character_set_results": "utf8",
                "character_set_server": "utf8",
                "collation_connection": "utf8_general_ci",
                "collation_server": "utf8_general_ci"
            }
        )
        db_parameter_group = aws_rds.CfnDBParameterGroup(
            self,
            "DbParameterGroup",
            description=core.Aws.STACK_NAME,
            family="aurora-mysql5.7",
            parameters={
                "general_log": "1",
                "log_output": "FILE",
                "log_queries_not_using_indexes": "1",
                "long_query_time": "10",
                "slow_query_log": "1"
            }
        )
        secret = aws_secretsmanager.CfnSecret(
            self,
            "Secret",
            generate_secret_string=aws_secretsmanager.CfnSecret.GenerateSecretStringProperty(
                exclude_characters="\"@/\\\"'$,[]*?{}~\#%<>|^",
                exclude_punctuation=True,
                generate_string_key="password",
                secret_string_template=json.dumps({"username":"dbadmin"})
            ),
            name="{}/wordpress/secret".format(core.Aws.STACK_NAME)
        )
        secret.cfn_options.condition = secret_arn_not_exists_condition
        config_secrets = [
            'AUTH_KEY',
            'AUTH_SALT',
            'LOGGED_IN_KEY',
            'LOGGED_IN_SALT',
            'NONCE_KEY',
            'NONCE_SALT',
            'SECURE_AUTH_KEY',
            'SECURE_AUTH_SALT'
        ]
        config_secret_constructs = {}
        for config_secret in config_secrets:
            config_secret_constructs[config_secret] = aws_secretsmanager.CfnSecret(
                self,
                "Config_{}".format(config_secret),
                generate_secret_string=aws_secretsmanager.CfnSecret.GenerateSecretStringProperty(
                    exclude_characters="\"'",
                    generate_string_key="value",
                    password_length=64,
                    secret_string_template=json.dumps({})
                ),
                name="{}/wordpress/secret_{}".format(core.Aws.STACK_NAME, config_secret)
            )

        db_cluster = aws_rds.CfnDBCluster(
            self,
            "DbCluster",
            database_name="wordpress",
            db_cluster_parameter_group_name=db_cluster_parameter_group.ref,
            db_subnet_group_name=db_subnet_group.ref,
            engine="aurora-mysql",
            engine_mode="provisioned",
            engine_version="5.7.mysql_aurora.2.08.0",
            master_username=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    core.Fn.condition_if(
                        secret_arn_exists_condition.logical_id,
                        core.Fn.sub("{{resolve:secretsmanager:${SecretArn}:SecretString:username}}"),
                        core.Fn.sub("{{resolve:secretsmanager:${Secret}:SecretString:username}}")
                    ),
                )
            ),
            master_user_password=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    core.Fn.condition_if(
                        secret_arn_exists_condition.logical_id,
                        core.Fn.sub("{{resolve:secretsmanager:${SecretArn}:SecretString:password}}"),
                        core.Fn.sub("{{resolve:secretsmanager:${Secret}:SecretString:password}}"),
                    ),
                )
            ),
            snapshot_identifier=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    db_snapshot_identifier_param.value_as_string,
                    core.Aws.NO_VALUE
                )
            ),
            storage_encrypted=True,
            vpc_security_group_ids=[ db_sg.ref ]
        )
        db_primary_instance = aws_rds.CfnDBInstance(
            self,
            "DbPrimaryInstance",
            db_cluster_identifier=db_cluster.ref,
            db_instance_class=db_instance_class_param.value_as_string,
            db_instance_identifier=core.Token.as_string(
                core.Fn.condition_if(
                    db_snapshot_identifier_exists_condition.logical_id,
                    core.Aws.NO_VALUE,
                    Util.append_stack_uuid("wordpress")
                )
            ),
            db_parameter_group_name=db_parameter_group.ref,
            db_subnet_group_name=db_subnet_group.ref,
            engine="aurora-mysql",
            # option_group_name="TODO",
            publicly_accessible=False
        )
        alb_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AlbSg",
            group_description="{}/AlbSg".format(core.Aws.STACK_NAME),
            vpc_id=vpc.id()
        )
        core.Tags.of(alb_sg).add("Name", "{}/AlbSg".format(core.Aws.STACK_NAME))
        alb_http_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpIngress",
            cidr_ip=alb_ingress_cidr_param.value_as_string,
            description="Allow HTTP traffic to ALB from anyone",
            from_port=80,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=80
        )
        alb_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpsIngress",
            cidr_ip=alb_ingress_cidr_param.value_as_string,
            description="Allow HTTPS traffic to ALB from anyone",
            from_port=443,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=443
        )
        alb = aws_elasticloadbalancingv2.CfnLoadBalancer(
            self,
            "AppAlb",
            scheme="internet-facing",
            security_groups=[ alb_sg.ref ],
            subnets=vpc.public_subnet_ids(),
            type="application"
        )
        http_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpListener",
            # These are updated in the override below to fix case of properties - see below
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    redirect_config=aws_elasticloadbalancingv2.CfnListener.RedirectConfigProperty(
                        host="#{host}",
                        path="/#{path}",
                        port="443",
                        protocol="HTTPS",
                        query="#{query}",
                        status_code="HTTP_301"
                    ),
                    type="redirect"
                )
            ],
            load_balancer_arn=alb.ref,
            port=80,
            protocol="HTTP"
        )
        # CDK generates ActionProperty with lowercase properties - need to override due to following error:
        # Stack operations on resource HttpListener would fail starting from 03/01/2021 as the template has invalid properties.
        # Please refer to the resource documentation to fix the template.
        # Properties validation failed for resource HttpListener with message:
        # #/DefaultActions/0: required key [Type] not found
        # #/DefaultActions/0: extraneous key [type] is not permitted
        # #/DefaultActions/0: extraneous key [redirectConfig] is not permitted
        http_listener.add_override(
            "Properties.DefaultActions",
            [
                {
                    'Type': 'redirect',
                    'RedirectConfig': {
                        'Host': "#{host}",
                        'Path': "/#{path}",
                        'Port': "443",
                        'Protocol': "HTTPS",
                        'Query': "#{query}",
                        'StatusCode': "HTTP_301"
                    }
                }
            ]
        )

        https_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "AsgHttpsTargetGroup",
            health_check_enabled=None,
            health_check_interval_seconds=None,
            port=443,
            protocol="HTTPS",
            target_group_attributes=[
                aws_elasticloadbalancingv2.CfnTargetGroup.TargetGroupAttributeProperty(
                    key='deregistration_delay.timeout_seconds',
                    value='10'
                )
            ],
            target_type="instance",
            vpc_id=vpc.id()
        )
        https_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpsListener",
            certificates=[
                aws_elasticloadbalancingv2.CfnListener.CertificateProperty(
                    certificate_arn=certificate_arn_param.value_as_string
                )
            ],
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=https_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=alb.ref,
            port=443,
            protocol="HTTPS"
        )

        # notifications
        notification_topic = aws_sns.CfnTopic(
            self,
            "NotificationTopic",
            topic_name=Util.append_stack_uuid(f"{core.Aws.STACK_NAME}-notifications")
        )
        notification_subscription = aws_sns.CfnSubscription(
            self,
            "NotificationSubscription",
            protocol="email",
            topic_arn=notification_topic.ref,
            endpoint=notification_email_param.value_as_string
        )
        notification_subscription.cfn_options.condition = notification_email_exists_condition
        iam_notification_publish_policy =aws_iam.PolicyDocument(
            statements=[
                aws_iam.PolicyStatement(
                    effect=aws_iam.Effect.ALLOW,
                    actions=[ "sns:Publish" ],
                    resources=[ notification_topic.ref ]
                )
            ]
        )

        system_log_group = aws_logs.CfnLogGroup(
            self,
            "WordPressSystemLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        system_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        system_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        access_log_group = aws_logs.CfnLogGroup(
            self,
            "WordPressAccessLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        access_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        access_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN
        error_log_group = aws_logs.CfnLogGroup(
            self,
            "WordPressErrorLogGroup",
            retention_in_days=TWO_YEARS_IN_DAYS
        )
        error_log_group.cfn_options.update_replace_policy = core.CfnDeletionPolicy.RETAIN
        error_log_group.cfn_options.deletion_policy = core.CfnDeletionPolicy.RETAIN

        # efs
        efs_sg = aws_ec2.CfnSecurityGroup(
            self,
            "EfsSg",
            group_description="{}/Efs".format(core.Aws.STACK_NAME),
            vpc_id=vpc.id()
        )
        efs_sg_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "EfsSgIngress",
            description="Allow EFS traffic from AppSg to EfsSg",
            from_port=2049,
            group_id=efs_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=app_sg.ref,
            to_port=2049
        )
        efs = aws_efs.CfnFileSystem(
            self,
            "AppEfs",
            encrypted=True
        )
        core.Tags.of(efs).add("Name", "{}/Efs".format(core.Aws.STACK_NAME))
        efs_mount_target1 = aws_efs.CfnMountTarget(
            self,
            "AppEfsMountTarget1",
            file_system_id=efs.ref,
            security_groups=[ efs_sg.ref ],
            subnet_id=vpc.private_subnet1_id()
        )
        efs_mount_target2 = aws_efs.CfnMountTarget(
            self,
            "AppEfsMountTarget2",
            file_system_id=efs.ref,
            security_groups=[ efs_sg.ref ],
            subnet_id=vpc.private_subnet2_id()
        )

        # app
        app_instance_role = aws_iam.CfnRole(
            self,
            "AppInstanceRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("ec2.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "logs:CreateLogStream",
                                    "logs:DescribeLogStreams",
                                    "logs:PutLogEvents"
                                ],
                                resources=[
                                    access_log_group.attr_arn,
                                    error_log_group.attr_arn,
                                    system_log_group.attr_arn
                                ]
                            )
                        ]
                    ),
                    policy_name="AllowStreamLogsToCloudWatch"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "ec2:DescribeVolumes",
                                    "ec2:DescribeTags",
                                    "cloudwatch:GetMetricStatistics",
                                    "cloudwatch:ListMetrics",
                                    "cloudwatch:PutMetricData"
                                ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="AllowStreamMetricsToCloudWatch"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="AllowGetFromArtifactBucket",
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "autoscaling:Describe*" ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="AllowDescribeAutoScaling"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "secretsmanager:GetSecretValue" ],
                                resources=[
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            secret_arn_exists_condition.logical_id,
                                            secret_arn_param.value_as_string,
                                            secret.ref
                                        )
                                    ),
                                    # TODO: could this be done without repeating the list?
                                    config_secret_constructs['AUTH_KEY'].ref,
                                    config_secret_constructs['AUTH_SALT'].ref,
                                    config_secret_constructs['LOGGED_IN_KEY'].ref,
                                    config_secret_constructs['LOGGED_IN_SALT'].ref,
                                    config_secret_constructs['NONCE_KEY'].ref,
                                    config_secret_constructs['NONCE_SALT'].ref,
                                    config_secret_constructs['SECURE_AUTH_KEY'].ref,
                                    config_secret_constructs['SECURE_AUTH_SALT'].ref
                                ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "secretsmanager:ListSecrets" ],
                                resources=[ "*" ],
                            ),
                        ]
                    ),
                    policy_name="WordPressSecretAccessPolicy"
                )
            ],
            managed_policy_arns=[
                "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
            ]
        )
        instance_profile = aws_iam.CfnInstanceProfile(
            self,
            "AppInstanceProfile",
            roles=[ app_instance_role.ref ]
        )

        # autoscaling
        with open("wordpress/app_launch_config_user_data.sh") as f:
            app_launch_config_user_data = f.read()
        launch_config = aws_autoscaling.CfnLaunchConfiguration(
            self,
            "AppLaunchConfig",
            image_id=core.Fn.find_in_map("AWSAMIRegionMap", core.Aws.REGION, "OEWORDPRESS"),
            instance_type=app_instance_type_param.value_as_string,
            iam_instance_profile=instance_profile.ref,
            key_name=core.Token.as_string(
                core.Fn.condition_if(
                    asg_key_name_exists_condition.logical_id,
                    asg_key_name_param.value_as_string,
                    core.Aws.NO_VALUE
                )
            ),
            security_groups=[app_sg.ref],
            user_data=(
                core.Fn.base64(
                    core.Fn.sub(
                        app_launch_config_user_data,
                        {
                            "WordPressHome": core.Token.as_string(
                                core.Fn.condition_if(
                                    word_press_hostname_exists_condition.logical_id,
                                    word_press_hostname_param.value_as_string,
                                    alb.attr_dns_name
                                )
                            ),
                            "SecretArn": core.Token.as_string(
                                core.Fn.condition_if(
                                    secret_arn_exists_condition.logical_id,
                                    secret_arn_param.value_as_string,
                                    secret.ref
                                )
                            ),
                            "Prefix": "{}/wordpress/secret".format(core.Aws.STACK_NAME)
                        }
                    )
                )
            )
        )
        asg = aws_autoscaling.CfnAutoScalingGroup(
            self,
            "AppAsg",
            launch_configuration_name=launch_config.ref,
            desired_capacity=core.Token.as_string(asg_desired_capacity_param.value),
            max_size=core.Token.as_string(asg_max_size_param.value),
            min_size=core.Token.as_string(asg_min_size_param.value),
            target_group_arns=[
                https_target_group.ref
            ],
            vpc_zone_identifier=vpc.private_subnet_ids()
        )
        asg.cfn_options.creation_policy=core.CfnCreationPolicy(
            resource_signal=core.CfnResourceSignal(
                count=1,
                timeout="PT15M"
            )
        )
        asg.cfn_options.update_policy=core.CfnUpdatePolicy(
            auto_scaling_rolling_update=core.CfnAutoScalingRollingUpdate(
                min_instances_in_service=1,
                pause_time="PT15M",
                wait_on_resource_signals=True
            ),
            auto_scaling_scheduled_action=core.CfnAutoScalingScheduledAction(
                ignore_unmodified_group_size_properties=True
            )
        )
        core.Tags.of(asg).add("Name", "{}/AppAsg".format(core.Aws.STACK_NAME))
        asg.add_depends_on(db_cluster)
        asg_web_server_scale_up_policy = aws_autoscaling.CfnScalingPolicy(
            self,
            "WebServerScaleUpPolicy",
            adjustment_type="ChangeInCapacity",
            auto_scaling_group_name=asg.ref,
            cooldown="60",
            scaling_adjustment=1
        )
        asg_web_server_scale_down_policy = aws_autoscaling.CfnScalingPolicy(
            self,
            "WebServerScaleDownPolicy",
            adjustment_type="ChangeInCapacity",
            auto_scaling_group_name=asg.ref,
            cooldown="60",
            scaling_adjustment=-1
        )

        # cloudwatch alarms
        cpu_alarm_high = aws_cloudwatch.CfnAlarm(
            self,
            "CpuAlarmHigh",
            comparison_operator="GreaterThanThreshold",
            evaluation_periods=2,
            actions_enabled=None,
            alarm_actions=[ asg_web_server_scale_up_policy.ref, notification_topic.ref ],
            alarm_description="Scale-up if CPU > 90% for 10mins",
            dimensions=[ aws_cloudwatch.CfnAlarm.DimensionProperty(
                name="AutoScalingGroupName",
                value=asg.ref
            )],
            metric_name="CPUUtilization",
            namespace="AWS/EC2",
            period=300,
            statistic="Average",
            threshold=90
        )
        cpu_alarm_low = aws_cloudwatch.CfnAlarm(
            self,
            "CpuAlarmLow",
            comparison_operator="LessThanThreshold",
            evaluation_periods=2,
            actions_enabled=None,
            alarm_actions=[ asg_web_server_scale_down_policy.ref, notification_topic.ref ],
            alarm_description="Scale-down if CPU < 70% for 10mins",
            dimensions=[ aws_cloudwatch.CfnAlarm.DimensionProperty(
                name="AutoScalingGroupName",
                value=asg.ref
            )],
            metric_name="CPUUtilization",
            namespace="AWS/EC2",
            period=300,
            statistic="Average",
            threshold=70
        )

        sg_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AppSgHttpsIngress",
            description="Allow HTTPS traffic from AlbSg to AppSg",
            from_port=443,
            group_id=app_sg.ref,
            ip_protocol="tcp",
            source_security_group_id=alb_sg.ref,
            to_port=443
        )

        # codebuild
        codebuild_transform_service_role = aws_iam.CfnRole(
            self,
            "CodeBuildTransformServiceRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("codebuild.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "logs:CreateLogGroup",
                                    "logs:CreateLogStream",
                                    "logs:PutLogEvents"
                                ],
                                resources=[ "*" ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:GetObject",
                                    "s3:PutObject"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="TransformRolePermssions"
                )
            ]
        )
        codebuild_transform_service_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codebuild_transform_service_role.ref,
                service="iam"
            ),
            stack=self
        )
        with open("wordpress/codebuild_transform_project_buildspec.yml") as f:
            codebuild_transform_project_buildspec = f.read()
        codebuild_transform_project = aws_codebuild.CfnProject(
            self,
            "CodeBuildTransformProject",
            artifacts=aws_codebuild.CfnProject.ArtifactsProperty(
                type="CODEPIPELINE",
            ),
            environment=aws_codebuild.CfnProject.EnvironmentProperty(
                compute_type="BUILD_GENERAL1_SMALL",
                environment_variables=[
                    aws_codebuild.CfnProject.EnvironmentVariableProperty(
                        name="AUTO_SCALING_GROUP_NAME",
                        value=asg.ref,
                    )
                ],
                image="aws/codebuild/standard:4.0",
                type="LINUX_CONTAINER"
            ),
            name="{}-transform".format(core.Aws.STACK_NAME),
            service_role=codebuild_transform_service_role_arn,
            source=aws_codebuild.CfnProject.SourceProperty(
                build_spec=codebuild_transform_project_buildspec,
                type="CODEPIPELINE"
            )
        )

        # codepipeline
        codepipeline_role = aws_iam.CfnRole(
            self,
            "PipelineRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("codepipeline.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "codebuild:BatchGetBuilds",
                                    "codebuild:StartBuild",
                                    "codedeploy:GetApplication",
                                    "codedeploy:GetDeploymentGroup",
                                    "codedeploy:ListApplications",
                                    "codedeploy:ListDeploymentGroups",
                                    "codepipeline:*",
                                    "iam:ListRoles",
                                    "iam:PassRole",
                                    "lambda:GetFunctionConfiguration",
                                    "lambda:ListFunctions",
                                    "s3:CreateBucket",
                                    "s3:GetBucketPolicy",
                                    "s3:GetObject",
                                    "s3:ListAllMyBuckets",
                                    "s3:ListBucket",
                                    "s3:PutBucketPolicy"
                                ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="CodePipelinePerms"
                )
            ]
        )
        codepipeline_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_role.ref,
                service="iam"
            ),
            stack=self
        )
        codepipeline_source_stage_role = aws_iam.CfnRole(
            self,
            "SourceStageRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ArnPrincipal(codepipeline_role_arn) ]
                    )
                ],
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*"
                                ],
                                resources=[ source_artifact_object_key_arn ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "s3:GetBucketVersioning" ],
                                resources=[
                                    core.Arn.format(
                                        components=core.ArnComponents(
                                            account="",
                                            region="",
                                            resource=source_artifact_bucket_name,
                                            service="s3"
                                        ),
                                        stack=self
                                    )
                                ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "s3:*" ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="SourceRolePerms"
                )
            ]
        )
        codepipeline_source_stage_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_source_stage_role.ref,
                service="iam"
            ),
            stack=self
        )
        codepipeline_deploy_stage_role = aws_iam.CfnRole(
            self,
            "DeployStageRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals= [ aws_iam.ArnPrincipal(codepipeline_role_arn) ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "codedeploy:*" ],
                                resources=[ "*" ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*",
                                    "s3:PutObject"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="DeployRolePerms"
                )
            ]
        )
        codepipeline_deploy_stage_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codepipeline_deploy_stage_role.ref,
                service="iam"
            ),
            stack=self
        )

        codedeploy_application = aws_codedeploy.CfnApplication(
            self,
            "CodeDeployApplication",
            application_name=core.Aws.STACK_NAME,
            compute_platform="Server"
        )
        codedeploy_role = aws_iam.CfnRole(
             self,
            "CodeDeployRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("codedeploy.{}.amazonaws.com".format(core.Aws.REGION)) ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:GetObject",
                                    "s3:PutObject"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            ),
                        ]
                    ),
                    policy_name="DeployRolePermssions"
                )
            ],
            managed_policy_arns=[ "arn:aws:iam::aws:policy/service-role/AWSCodeDeployRole" ]
        )
        codedeploy_role_arn = core.Arn.format(
            components=core.ArnComponents(
                account=core.Aws.ACCOUNT_ID,
                region="",
                resource="role",
                resource_name=codedeploy_role.ref,
                service="iam"
            ),
            stack=self
        )
        codedeploy_deployment_group = aws_codedeploy.CfnDeploymentGroup(
            self,
            "CodeDeployDeploymentGroup",
            application_name=codedeploy_application.application_name,
            auto_scaling_groups=[ asg.ref ],
            deployment_group_name="{}-app".format(core.Aws.STACK_NAME),
            deployment_config_name=aws_codedeploy.ServerDeploymentConfig.ALL_AT_ONCE.deployment_config_name,
            service_role_arn=codedeploy_role_arn,
            trigger_configurations=[
                aws_codedeploy.CfnDeploymentGroup.TriggerConfigProperty(
                    trigger_events=[
                        "DeploymentSuccess",
                        "DeploymentRollback"
                    ],
                    trigger_name="DeploymentNotification",
                    trigger_target_arn=notification_topic.ref
                )
            ]
        )
        codepipeline = aws_codepipeline.CfnPipeline(
            self,
            "Pipeline",
            artifact_store=aws_codepipeline.CfnPipeline.ArtifactStoreProperty(
                location=core.Token.as_string(
                    core.Fn.condition_if(
                        pipeline_artifact_bucket_name_exists_condition.logical_id,
                        pipeline_artifact_bucket_name_param.value_as_string,
                        pipeline_artifact_bucket.ref
                    )
                ),
                type="S3"
            ),
            role_arn=codepipeline_role_arn,
            stages=[
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Source",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Source",
                                owner="AWS",
                                provider="S3",
                                version="1"
                            ),
                            configuration={
                                "S3Bucket": source_artifact_bucket_name,
                                "S3ObjectKey": source_artifact_object_key_param.value_as_string
                            },
                            output_artifacts=[
                                aws_codepipeline.CfnPipeline.OutputArtifactProperty(
                                    name="build"
                                )
                            ],
                            name="SourceAction",
                            role_arn=codepipeline_source_stage_role_arn
                        )
                    ]
                ),
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Transform",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Build",
                                owner="AWS",
                                provider="CodeBuild",
                                version="1"
                            ),
                            configuration={
                                "ProjectName": codebuild_transform_project.ref
                            },
                            input_artifacts=[
                                aws_codepipeline.CfnPipeline.InputArtifactProperty(
                                    name="build",
                                )
                            ],
                            name="TransformAction",
                            output_artifacts=[
                                aws_codepipeline.CfnPipeline.OutputArtifactProperty(
                                    name="transformed"
                                )
                            ]
                        )
                    ]
                ),
                aws_codepipeline.CfnPipeline.StageDeclarationProperty(
                    name="Deploy",
                    actions=[
                        aws_codepipeline.CfnPipeline.ActionDeclarationProperty(
                            action_type_id=aws_codepipeline.CfnPipeline.ActionTypeIdProperty(
                                category="Deploy",
                                owner="AWS",
                                provider="CodeDeploy",
                                version="1"
                            ),
                            configuration={
                                "ApplicationName": codedeploy_application.ref,
                                "DeploymentGroupName": codedeploy_deployment_group.ref,
                            },
                            input_artifacts=[
                                aws_codepipeline.CfnPipeline.InputArtifactProperty(
                                    name="transformed"
                                )
                            ],
                            name="DeployAction",
                            role_arn=codepipeline_deploy_stage_role_arn
                        )
                    ]
                )
            ]
        )

        # default wordpress
        initialize_default_wordpress_lambda_function_role = aws_iam.CfnRole(
            self,
            "InitializeDefaultWordPressLambdaFunctionRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("lambda.amazonaws.com") ]
                    )
                ]
            ),
            managed_policy_arns=[
                "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            ],
            policies=[
                # OE default wordpress artifact should be public, so no policy needed for s3:GetObject
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "s3:ListBucket" ],
                                resources=[ source_artifact_bucket_arn ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:HeadObject",
                                    "s3:PutObject"
                                ],
                                resources=[ source_artifact_object_key_arn ]
                            )
                        ]
                    ),
                    policy_name="PutDefaultWordPressArtifact"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=iam_notification_publish_policy,
                    policy_name="SnsPublishToNotificationTopic"
                )
            ]
        )
        initialize_default_wordpress_lambda_function_role.cfn_options.condition = initialize_default_wordpress_condition
        with open("wordpress/initialize_default_wordpress_lambda_function_code.py") as f:
            initialize_default_wordpress_lambda_function_code = f.read()
        initialize_default_wordpress_lambda_function = aws_lambda.CfnFunction(
            self,
            "InitializeDefaultWordPressLambdaFunction",
            code=aws_lambda.CfnFunction.CodeProperty(
                zip_file=initialize_default_wordpress_lambda_function_code
            ),
            dead_letter_config=aws_lambda.CfnFunction.DeadLetterConfigProperty(
                target_arn=notification_topic.ref
            ),
            environment=aws_lambda.CfnFunction.EnvironmentProperty(
                variables={
                    "DefaultWordPressSourceUrl": DEFAULT_WORDPRESS_SOURCE_URL,
                    "SourceArtifactBucket": source_artifact_bucket_name,
                    "SourceArtifactObjectKey": source_artifact_object_key_param.value_as_string,
                    "StackName": core.Aws.STACK_NAME
                }
            ),
            handler="index.lambda_handler",
            role=initialize_default_wordpress_lambda_function_role.attr_arn,
            runtime="python3.7",
            timeout=300
        )
        initialize_default_wordpress_lambda_function.cfn_options.condition = initialize_default_wordpress_condition
        initialize_default_wordpress_custom_resource = aws_cloudformation.CfnCustomResource(
            self,
            "InitializeDefaultWordPressCustomResource",
            service_token=initialize_default_wordpress_lambda_function.attr_arn
        )
        initialize_default_wordpress_custom_resource.cfn_options.condition = initialize_default_wordpress_condition


        #
        # OUTPUTS
        #
        source_artifact_bucket_name_output = core.CfnOutput(
            self,
            "SourceArtifactBucketNameOutput",
            description="The source artifact S3 bucket name that is monitored for updates to be deployed",
            value=source_artifact_bucket_name
        )
        source_artifact_object_key_output = core.CfnOutput(
            self,
            "SourceArtifactObjectKeyOutput",
            description="The source artifact S3 object key that is monitored for updates to be deployed",
            value=source_artifact_object_key_param.value_as_string
        )
        word_press_site_url_output = core.CfnOutput(
            self,
            "WordPressSiteUrlOutput",
            description="The WordPress URL Endpoint",
            value=core.Token.as_string(
                core.Fn.condition_if(
                word_press_hostname_exists_condition.logical_id,
                "https://{}".format(word_press_hostname_param.value_as_string),
                "https://{}".format(alb.attr_dns_name)
            ))
        )

        # route 53
        record_set = aws_route53.CfnRecordSet(
            self,
            "RecordSet",
            hosted_zone_name=f"{route_53_hosted_zone_name_param.value_as_string}.",
            name=word_press_hostname_param.value_as_string,
            resource_records=[ alb.attr_dns_name ],
            type="CNAME"
        )
        # https://github.com/aws/aws-cdk/issues/8431
        record_set.add_property_override("TTL", 60)
        record_set.cfn_options.condition = route_53_hosted_zone_name_exists_condition

        # AWS::CloudFormation::Interface
        self.template_options.metadata = {
            "OE::Patterns::TemplateVersion": template_version,
            "AWS::CloudFormation::Interface": {
                "ParameterGroups": [
                    {
                        "Label": {
                            "default": "Application Config"
                        },
                        "Parameters": [
                            word_press_hostname_param.logical_id,
                            route_53_hosted_zone_name_param.logical_id,
                            alb_ingress_cidr_param.logical_id,
                            certificate_arn_param.logical_id,
                            secret_arn_param.logical_id,
                            app_instance_type_param.logical_id,
                            asg_key_name_param.logical_id,
                            asg_min_size_param.logical_id,
                            asg_max_size_param.logical_id,
                            asg_desired_capacity_param.logical_id,
                            initialize_default_wordpress_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "CI/CD"
                        },
                        "Parameters": [
                            notification_email_param.logical_id,
                            source_artifact_bucket_name_param.logical_id,
                            source_artifact_object_key_param.logical_id
                        ]
                    },
                    {
                        "Label": {
                            "default": "Database Configuration"
                        },
                        "Parameters": [
                            db_instance_class_param.logical_id,
                            db_snapshot_identifier_param.logical_id
                        ]
                    },
                    *vpc.metadata_parameter_group(),
                    {
                        "Label": {
                            "default": "Template Development"
                        },
                        "Parameters": [
                            pipeline_artifact_bucket_name_param.logical_id
                        ]
                    }
                ],
                "ParameterLabels": {
                    alb_ingress_cidr_param.logical_id: {
                        "default": "ALB Ingress CIDR"
                    },
                    app_instance_type_param.logical_id: {
                        "default": "Instance Type"
                    },
                    asg_key_name_param.logical_id: {
                        "default": "Auto Scaling Group EC2 Key Name"
                    },
                    asg_desired_capacity_param.logical_id: {
                        "default": "Auto Scaling Group Desired Capacity"
                    },
                    asg_max_size_param.logical_id: {
                        "default": "Auto Scaling Group Maximum Size"
                    },
                    asg_min_size_param.logical_id: {
                        "default": "Auto Scaling Group Minimum Size"
                    },
                    certificate_arn_param.logical_id: {
                        "default": "ACM Certificate ARN"
                    },
                    db_snapshot_identifier_param.logical_id: {
                        "default": "RDS Snapshot Identifier"
                    },
                    db_instance_class_param.logical_id: {
                        "default": "RDS Instance Class"
                    },
                    initialize_default_wordpress_param.logical_id: {
                        "default": "Initialize with a default WordPress codebase"
                    },
                    notification_email_param.logical_id: {
                        "default": "Notification Email"
                    },
                    pipeline_artifact_bucket_name_param.logical_id: {
                        "default": "CodePipeline Bucket Name"
                    },
                    secret_arn_param.logical_id: {
                        "default": "Secrets Manager secret ARN"
                    },
                    route_53_hosted_zone_name_param.logical_id: {
                        "default": "Route 53 Hosted Zone Name"
                    },
                    source_artifact_bucket_name_param.logical_id: {
                        "default": "Source Artifact S3 Bucket Name"
                    },
                    source_artifact_object_key_param.logical_id: {
                        "default": "Source Artifact S3 Object Key (path)"
                    },
                    word_press_hostname_param.logical_id: {
                        "default": "WordPress Hostname"
                    },
                    **vpc.metadata_parameter_labels()
                }
            }
        }
